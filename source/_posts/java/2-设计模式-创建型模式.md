title: 设计模式-创建型模式

tags:
  - Java

categories:
  - Java

---
### 概述
![概述图片](https://image-static.segmentfault.com/265/497/2654976967-5ad605a966706_articlex)
### 设计模式原则
1. 开闭   
`开闭原则就是说对扩展开放，对修改关闭，这样可以使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。`
2. 里氏替换   
`任何基类可以出现的地方，子类一定可以出现。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。`
3. 依赖倒转   
`是开闭原则的基础，基于接口编程，依赖于抽象而不依赖于具体。`
3. 接口隔离   
`使用多个隔离的接口，比使用单个接口要好，降低类之间的耦合度。`
4. 迪米特法则（最少知道）  
`一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。`
5. 合成复用   
`原则是尽量使用合成/聚合的方式，而不是使用继承。`

### 创建型模式
#### 1. 单例模式
在一个JVM中，该对象只有一个实例存在。单例模式的优势：1. 避免频繁地创建实例，减轻系统压力；2. 避免创建多个实例引发的数据一致性问题。
- 一个简单的单例类

```java
public class Singleton {

  // 私有静态实例，防止被引用；
  // 初始化为null，目的是实现延迟加载
  private static Singleton instance = null;

  // 私有化构造方法，防止被实例化
  private Singleton() {}

  // 静态工厂方法，创建实例
  public static Singleton getInstance() {
    if (instance == null) {
      instance = new Singleton();
    }
    return instance;
  }

  public static void main(String[] args) {
    getInstance();
  }
}
```
- 一个比较完美的单例类，避免了线程安全问题。

```java
//单例模式使用内部类来维护单例的实现，
//JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。
//这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，
//并且会保证把赋值给instance的内存初始化完毕
public class Singleton {
  // 私有构造方法，防止被实例化
  private Singleton {}
  // 使用内部类维护单例
  private static class SingletonFactory {
    private static Singleton instance = new Singleton();
  }
  // 获取实例
  public static Singleton getInstance(){
    return SingletonFactory.instance;
  }
}
```
#### 2. 工厂方法模式
凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。大多数情况下，我们会选用静态工厂方法模式。

```java
public class TestFactoryMethod {

  public interface Sender {
    public void send();
  }

  public class MailSender implements Sender {
    @Override
    public void send() {
      System.out.println("send mail");
    }
  }

  public class SmsSender implements Sender {
    @Override
    public void send() {
      System.out.println("send sms");
    }
  }

  public static class SendFactory {
    public static Sender produceMail() {
      return new TestFactoryMethod().new MailSender();
    }

    public static Sender produceSms() {
      return new TestFactoryMethod().new SmsSender();
    }
  }

  public static void main(String[] args) {
    Sender sender = TestFactoryMethod.SendFactory.produceMail();
    sender.send();
  }
}
// 输出：
// send mail
```
#### 3. 抽象工厂模式
工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了开闭原则。抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码  

```java
public class TestAbstractFactory {

  public interface Provider {
    public Sender produce();
  }

  public interface Sender {
    public void send();
  }

  public class MailSender implements Sender {
    @Override
    public void send() {
      System.out.println("send mail");
    }
  }

  public class SmsSender implements Sender {
    @Override
    public void send() {
      System.out.println("send sms");
    }
  }

  public class SendMailFactory implements Provider {
    @Override
    public Sender produce() {
      return new MailSender();
    }
  }

  public class SendSmsFactory implements Provider {
    @Override
    public Sender produce() {
      return new SmsSender();
    }
  }

  public static void main(String[] args) {
    Provider provider = new TestAbstractFactory().new SendMailFactory();
    Sender sender = provider.produce();
    sender.send();
  }
}
// 输出：
// send mail
```
#### 4. 建造者模式
工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象。

```java
import java.util.ArrayList;
import java.util.List;

public class TestBuilder {

  private List<Sender> list = new ArrayList<>();

  public interface Sender {
    public void send();
  }

  public class MailSender implements Sender {
    @Override
    public void send() {
      System.out.println("send mail");
    }
  }

  public class SmsSender implements Sender {
    @Override
    public void send() {
      System.out.println("send sms");
    }
  }

  public void produceMailSender(int count) {
    for (int i = 0; i < count; i++) {
      list.add(new MailSender());
    }
  }

  public void produceSmsSender(int count) {
    for (int i = 0; i < count; i++) {
      list.add(new SmsSender());
    }
  }

  public static void main(String[] args) {
    TestBuilder builder = new TestBuilder();
    builder.produceMailSender(5);
    for (Sender sender : builder.list) {
      sender.send();
    }
  }
}
//输出：
// send mail
// send mail
// send mail
// send mail
// send mail
```
#### 5. 原型模式
将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。对象深、浅复制的概念：
- 浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。
- 深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。

```java
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

public class TestPrototype implements Cloneable, Serializable {
  private static final long serialVersionUID = 1L;

  class SerializableObject implements Serializable {
    private static final long serialVersionUID = 1L;
  }

  // 1. 浅复制： 实现Cloneable接口，重写clone方法
  public Object clone() throws CloneNotSupportedException {
    TestPrototype prototype = (TestPrototype) super.clone();
    return prototype;
  }

  // 2. 深复制：采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象
  public Object deepClone() throws IOException, ClassNotFoundException {
    // 写入当前对象的二进制流
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream(bos);
    oos.writeObject(this);

    // 读出二进制流产生的新对象
    ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
    ObjectInputStream ois = new ObjectInputStream(bis);
    return ois.readObject();
  }

}
```

### 参考链接：
  - [图说设计模式](http://design-patterns.readthedocs.org/zh_CN/latest/index.html)
  - [java的常用设计模式](https://segmentfault.com/a/1190000008074146)
  - [Java的23种设计模式](https://segmentfault.com/a/1190000014459721)
