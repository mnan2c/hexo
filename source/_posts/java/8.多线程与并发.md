title: 多线程与并发

tags:
  - Java

categories:
  - Java

---
## 1. 进程与线程
- 进程：进程是具有独立功能的程序在一个数据集合上运行的过程，是系统进行**资源分配的基本单位**。每一个进程都有它自己的内存空间和系统资源。进程实现多处理机环境下的进程调度，分派，切换时，都需要花费较大的时间和空间开销
- 线程：在同一个进程内又可以执行多个任务，而这每一个任务我就可以看出是一个线程。引入线程主要是为了提高系统的执行效率，减少处理机的空转时间和调度切换的时间，以及便于系统管理。线程是**资源调度的基本单位**。

## 2. Java实现多线程
### 2.1 继承Thread类，重写run方法
```java
public class MyThread extends Thread {

  @Override
  public void run() {
    for (int x = 0; x < 200; x++) {
      System.out.println(x);
    }
  }

  public static void main(String[] args) {
    // 创建两个线程对象
    MyThread my1 = new MyThread();
    MyThread my2 = new MyThread();

    my1.start();
    my2.start();
  }
}
```

### 2.2 实现Runnable接口，重写run方法
```java
public class MyRunnable implements Runnable {

  @Override
  public void run() {
    for (int x = 0; x < 100; x++) {
      System.out.println(x);
    }
  }
}
```
## 3. 竞态条件与临界区
在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services 等）或文件。实际上，这些问题只有在一或多个线程向这些资源做了写操作时才有可能发生，只要资源没有发生变化，多个线程读取相同的资源就是安全的。

```java
public class Counter {
    protected long count = 0;
    public void add(long value){
        this.count = this.count + value;   
    }
}
当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。上例中 add()方法就是一个临界区,它会产生竞态条件。在临界区中使用适当的同步就可以避免竞态条件。
```
## 4. 并发与解决方案
### 4.0 并发编程中的三个概念
#### 4.0.1 原子性
即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。经典的例子就是银行账户转账问题。
#### 4.0.2 可见性
可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

```java
//线程1执行的代码
int i = 0;
i = 10;

//线程2执行的代码
j = i;

// 假若执行线程1的是CPU1，执行线程2的是CPU2。
// 由上面的分析可知，当线程1执行 i=10这句时，
// 会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，
// 那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。
// 此时线程2执行 j = i，
// 它会先去主存读取i的值并加载到CPU2的缓存当中，
// 此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.
```
#### 4.0.3 有序性
即程序执行的顺序按照代码的先后顺序执行。指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。
### 4.1 控制并发的方式
- 最基础的synchronized，juc中的lock
- 数据库的行级锁，乐观锁，悲观锁
- 中间件级别的redis，zookeeper分布式锁

双11那种级别的秒杀需要多层架构去控制并发，前端拦截，负载均衡…不能仅仅依赖于数据库，会导致严重的性能问题。

### 4.2 业务场景分析
1. 修改个人信息：几乎不存在并发，不需要控制，场景乐观。每个人只可以修改自己的信息，所以，不同用户的操作其实是隔离的，所以不算“并发”。
2. 修改商品信息：存在并发，需要控制，允许失败，场景乐观。系统中可能有多个操作员来维护，此时，商品数据表现为一个共享数据，所以存在微弱的并发。`通常这种场景使用乐观锁，即在商品属性添加一个version字段标记修改的版本，这样两个操作员拿到同一个版本号，第一个操作员修改成功后版本号变化，另一个操作员的修改就会失败了。`
```java
class Goods{
  @Version
  int version;
}
```
3. 扣除账户余额，扣减库存：存在频繁的并发，需要控制，不允许失败，场景悲观。
```java
// 可以利用数据库的行级锁
// 然后在后台查看返回值是否影响行数为1，判断请求是否成功，利用数据库保证并发。
update set balance = balance - money where userId = ? and balance >= money;
```

## 3. 注意点
1. jvm虚拟机的启动是多线程的。不仅仅是启动main线程，还至少会启动垃圾回收线程。
2. 一般我们使用实现Runnable接口的方式实现多线程，这样可以避免java中的单继承的限制。
